<?php
/**
 * Use a hook exposed in the membership_entity_term module to recalculate the end date of the membership
 * @param  dateObject &$end  The original End date for membership
 * @param  membership_term_entity  &$term  The term entity
 * @return dateObject  The amended end date.
 */
function beekeeper_custom_membership_entity_term_end_date_alter(&$end, &$term){
  // Temp - if this is a dummy membership (type = "membership")
  // then make the end date 31 May this year
  if ($term->membership_entity_type == 'membership') {
    $end = new DateObject(strtotime("31 May this year"), new DateTimezone($term->timezone));
  }
  else {
    $end = new DateObject(strtotime("31 May next year"), new DateTimezone($term->timezone));
  }
}

/**
 * Use a hook exposed in the membership_entity_term module to recalculate the start date of the membership
 * @param  dateObject &$start  The original Start date for membership
 * @param  membership_term_entity  &$term  The term entity
 * @return dateObject  The amended start date.
 */
function beekeeper_custom_membership_entity_term_start_date_alter(&$start, &$term){
  // Temp - if this is a dummy membership (type = "membership")
  // then make the start date 30 May this year
  if ($term->membership_entity_type == 'membership') {
    $start = new DateObject(strtotime("30 May this year"), new DateTimezone($term->timezone));
  }
}

/**
 * Implements hook_entity_presave
 */
function beekeeper_custom_entity_presave($entity, $type) {
  switch ($type) {
    case 'membership_entity':
      if ($entity->type == 'membership') {
        // This is a dummy membership, so convert it to an expired standard membership
        $entity->type = 'standard_membership';
        $entity->status = 0;
      }
      break;
    case 'membership_entity_term':
      if ($entity->membership_entity_type == 'membership') {
        // This is a dummy membership, so convert it to an expired standard membership
        $entity->membership_entity_type = 'standard_membership';
        $entity->status = 0;
      }
      break;
  }
}


/**
 * Implementation of hook_rules_condition_info().
 */
function beekeeper_custom_rules_condition_info() {
    return array(
        'beekeeper_custom_rules_condition_send_renewal_notifications' => array(
            'label' => t('Send renewal notification emails?'),
            'group' => 'Beekeeper Custom',
        )
    );
}

/**
 * Condition to make sure membership renewal notifications are sent out on the 31st of May,
 * and uses a "notifications_sent" variable to make sure the notifications are only sent out
 * once no matter how many times cron is run that day.
 */
function beekeeper_custom_rules_condition_send_renewal_notifications() {
    $today = date('z');
    $renewal_date = date('z', strtotime("31 May this year"));
    if($today==$renewal_date){
      if(strcmp(variable_get('notifications_sent'), 'true')!=0){
        variable_set('notifications_sent', 'true');
        return true;
      }else{
        return false;
      }

    }else{
      variable_set('notifications_sent', 'false');
      return false;
    }

}

/**
 * Function to massage imported data to ensure that the address elements are correct
 *
 * Implements hook_feeds_presave
 */
function beekeeper_custom_feeds_presave($source, $entity, $item) {
  // Put the address data into the correct field elements
  $entity->field_postal_address = array(
    LANGUAGE_NONE => array(
      0 => array(
        'country' => $item['country'],
        'administrative_area' => '',
        'sub_administrative_area' => '',
        'locality' => $item['town_city'],
        'dependent_locality' => $item['suburb'],
        'postal_code' => $item['postcode'],
        'thoroughfare' => $item['address_line1'],
        'premise' => $item['address_line2'],
        'sub_premise' => '',
        'organisation_name' => '',
        'name_line' => $item['first_name'] . ' ' . $item['surname'],
        'first_name' => $item['first_name'],
        'last_name' => $item['surname'],
        'data' => '',
      )
    )
  );

  // Split the telephone number field on multiple phone numbers
  $phone_number = $entity->field_phone_number[LANGUAGE_NONE][0]['value'];
  $phone_numbers = explode(';', $phone_number);
  $entity->field_phone_number[LANGUAGE_NONE] = array();
  foreach ($phone_numbers as $phone_number) {
    $entity->field_phone_number[LANGUAGE_NONE][] = array('value' => trim($phone_number));
  }
}

/**
 * Implements hook_block
 */
function beekeeper_custom_block_info() {
  $blocks['curruser'] = array(
    'info' => t('Current user'),
    'cache' => DRUPAL_CACHE_PER_USER,
  );
  $blocks['ruleoff'] = array(
    'info' => t('Rule off'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  return $blocks;
}


/**
 * Implements hook_block_view
 */
function beekeeper_custom_block_view($delta = '') {
  $subject = NULL;
  switch ($delta) {
    case 'curruser':
      global $user;
      $content = '<span class="beekeeper-username">';
      if ($user->uid) {
        $content .= $user->name . '</span>&nbsp;&nbsp<a href="/user/logout">(logout)</a>';
      }
      else {
        $content .= 'anonymous</span>&nbsp;&nbsp<a href="/user/login">(login)</a>';
      }
      break;
    case 'ruleoff':
      $content = '<div class="beekeeper-rule-off"></div>';
      break;
    default:
      $content = '';
  }
  // Return array holding block information
  return array(
    'subject' => $subject,
    'content' => array('#markup' => $content),
  );
}
